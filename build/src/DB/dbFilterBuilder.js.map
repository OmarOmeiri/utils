{"version":3,"file":"dbFilterBuilder.js","sourceRoot":"","sources":["../../../src/DB/dbFilterBuilder.ts"],"names":[],"mappings":";AAAA;;;;GAIG;;AAGH,2DAU4B;AAE5B,MAAM,eAAe,GAAG,CAA8B,EACpD,GAAG,EACH,KAAK,EACL,KAAK,GACS,EAA2B,EAAE;IAC3C,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,0CAAqB,CAAC,CAAC;IACrD,IAAI,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;QAC3B,OAAO;YACL,CAAC,KAAK,CAAC,EAAE;gBACP,CAAC,0CAAqB,CAAC,GAAyC,CAAC,CAAC,EAAE,KAAK;aAC1E;SACyB,CAAC;KAC9B;IAED,OAAO;QACL,CAAC,KAAK,CAAC,EAAE,KAAK;KACY,CAAC;AAC/B,CAAC,CAAC;AAEF,MAAM,YAAY,GAAG,CAA8B,EACjD,GAAG,EACH,KAAK,EACL,KAAK,GACM,EACX,SAAyB,EACA,EAAE;IAC3B,IAAI,GAAG,KAAK,UAAU,EAAE;QACtB,IAAI,KAAK,IAAI,SAAS,CAAC,SAAS,EAAE;YAChC,OAAO;gBACL,CAAC,KAAK,CAAC,EAAE;oBACP,MAAM,EAAE;wBACN,QAAQ,EAAE,KAAK;qBAChB;iBACF;aACyB,CAAC;SAC9B;QACD,OAAO;YACL,CAAC,KAAK,CAAC,EAAE;gBACP,OAAO,EAAE,IAAI,KAAK,GAAG;gBACrB,OAAO,EAAE,GAAG;aACb;SACyB,CAAC;KAC9B;IACD,OAAO,EAAE,CAAC,KAAK,CAAC,EAAE,KAAK,EAA6B,CAAC;AACvD,CAAC,CAAC;AAEF,MAAM,eAAe,GAAG,CAA8B,EACpD,KAAK,EACL,KAAK,GACS,EACW,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,KAAK,EAA8B,CAAA,CAAC;AAE9E,mFAAmF;AACnF,0BAA0B;AAC1B,uBAAuB;AACvB,iBAAiB;AACjB,mDAAmD;AACnD,yCAAyC;AACzC,8CAA8C;AAC9C,yCAAyC;AACzC,qCAAqC;AACrC,4CAA4C;AAC5C,yCAAyC;AACzC,WAAW;AACX,eAAe;AACf,qBAAqB;AACrB,MAAM;AACN,KAAK;AAEL;;;;;;;GAOG;AACH,0DAA0D;AAC1D,yBAAyB;AACzB,mCAAmC;AACnC,mBAAmB;AACnB,8CAA8C;AAC9C,uDAAuD;AACvD,sDAAsD;AACtD,mDAAmD;AAEnD,sCAAsC;AAEtC,wDAAwD;AACxD,gCAAgC;AAChC,uCAAuC;AACvC,iCAAiC;AACjC,wBAAwB;AACxB,6CAA6C;AAC7C,mDAAmD;AACnD,iEAAiE;AACjE,UAAU;AACV,4CAA4C;AAC5C,qDAAqD;AACrD,wDAAwD;AACxD,UAAU;AACV,eAAe;AACf,oDAAoD;AACpD,uDAAuD;AACvD,QAAQ;AACR,MAAM;AACN,qFAAqF;AACrF,iFAAiF;AACjF,KAAK;AAEL,mCAAmC","sourcesContent":["/**\n * Db filtering utility functions\n * @module DBFilterUtils\n * @category DB\n */\n\nimport type mongoose from 'mongoose';\nimport {\n  NumericFilter,\n  TextFilter,\n  BooleanFilter,\n  // IFilters,\n  MongoNumericFilterMap,\n  // TextFilterRuleKeys,\n  // NumericFilterRuleKeys,\n  // filterCollections,\n  FilterMapCombo,\n} from 'lullo-common-types';\n\nconst genNumericQuery = <T extends mongoose.Document>({\n  key,\n  value,\n  field,\n}: NumericFilter): mongoose.FilterQuery<T> => {\n  const mongoKeys = Object.keys(MongoNumericFilterMap);\n  if (mongoKeys.includes(key)) {\n    return {\n      [field]: {\n        [MongoNumericFilterMap[key as keyof typeof MongoNumericFilterMap]]: value,\n      },\n    } as mongoose.FilterQuery<T>;\n  }\n\n  return {\n    [field]: value,\n  } as mongoose.FilterQuery<T>;\n};\n\nconst genTextQuery = <T extends mongoose.Document>({\n  key,\n  value,\n  field,\n}: TextFilter,\n  filterMap: FilterMapCombo,\n): mongoose.FilterQuery<T> => {\n  if (key === 'contains') {\n    if (field in filterMap.textIndex) {\n      return {\n        [field]: {\n          _$text: {\n            _$search: value,\n          },\n        },\n      } as mongoose.FilterQuery<T>;\n    }\n    return {\n      [field]: {\n        _$regex: `/${value}/`,\n        options: 'i',\n      },\n    } as mongoose.FilterQuery<T>;\n  }\n  return { [field]: value } as mongoose.FilterQuery<T>;\n};\n\nconst genBooleanQuery = <T extends mongoose.Document>({\n  value,\n  field,\n}: BooleanFilter,\n): mongoose.FilterQuery<T> => ({ [field]: value } as mongoose.FilterQuery<T>);\n\n// const getFilterMap = (collection: filterCollections): FilterMapCombo | null => {\n//   switch (collection) {\n//     case 'products':\n//       return {\n//         textIndex: productTextFilterIndexFields,\n//         text: productTextFilterFields,\n//         number: productNumericFilterFields,\n//         date: productDateFilterFields,\n//         id: productIdFilterFields,\n//         bool: productBooleanFilterFields,\n//         enum: productEnumFilterFields,\n//       };\n//     default:\n//       return null;\n//   }\n// };\n\n/**\n * Builds a mongoDB query for a given array of filters. See {@link FiltersInterfaces.IFilters}\n *\n * The mocked param puts a \"_\" in front of the mongoDB keywords to avoid errors when saving the filters to DB\n * @param filters\n * @param mocked Defaults to true\n * @returns\n */\n// const buildFilterQuery = <T extends mongoose.Document>(\n//   filters: IFilters[],\n//   collection: filterCollections,\n//   mocked = true,\n// ): mongoose.FilterQuery<T> | undefined => {\n//   const filterArray: mongoose.FilterQuery<T>[] = [];\n//   const textKeys = Object.keys(TextFilterRuleKeys);\n//   // const filterMap = getFilterMap(collection);\n\n//   if (!filterMap) return undefined;\n\n//   const numKeys = Object.keys(NumericFilterRuleKeys);\n//   const lng = filters.length;\n//   for (let i = 0; i < lng; i += 1) {\n//     const filter = filters[i];\n//     if (filter.key) {\n//       if (textKeys.includes(filter.key)) {\n//         const textFilter = filter as TextFilter;\n//         filterArray.push(genTextQuery(textFilter, filterMap));\n//       }\n//       if (numKeys.includes(filter.key)) {\n//         const numFilter = filter as NumericFilter;\n//         filterArray.push(genNumericQuery(numFilter));\n//       }\n//     } else {\n//       const boolFilter = filter as BooleanFilter;\n//       filterArray.push(genBooleanQuery(boolFilter));\n//     }\n//   }\n//   if (mocked) return { _$and: filterArray } as unknown as mongoose.FilterQuery<T>;\n//   return JSON.parse(JSON.stringify({ _$and: filterArray }).replace(/_/g, ''));\n// };\n\n// export default buildFilterQuery;\n"]}