{"version":3,"file":"timerFuncs.js","sourceRoot":"","sources":["../../../src/Timer/timerFuncs.ts"],"names":[],"mappings":";AAAA;;;;GAIG;;;AAEH,+BAA+B;AAC/B;;;;;GAKG;AACH,SAAgB,eAAe,CAAuB,QAA8B,EAAE,IAAY;IAChG,IAAI,OAAuB,CAAC;IAC5B,OAAO,CAAC,GAAG,IAAO,EAAE,EAAE;QACpB,YAAY,CAAC,OAAO,CAAC,CAAC;QACtB,aAAa;QACb,OAAO,GAAG,UAAU,CAAC,cAAoB,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;IAChF,CAAC,CAAC;AACJ,CAAC;AAPD,0CAOC;AAED;;;;GAIG;AACH,SAAgB,UAAU,CAAC,OAAe;IACxC,OAAO,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE;QACnC,UAAU,CAAC,GAAG,EAAE,GAAG,OAAO,EAAE,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;IAC5C,CAAC,CAAC,CAAC;AACL,CAAC;AAJD,gCAIC;AAED;;;;;;GAMG;AACH,SAAgB,SAAS,CAAC,EAAU;IAClC,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC;IAC5B,OAAO,IAAI,CAAC,GAAG,EAAE,GAAG,GAAG;QAAE,SAAS;AACpC,CAAC;AAHD,8BAGC;AAED;;;;;;GAMG;AACH,SAAgB,QAAQ,CACtB,IAA0B,EAC1B,IAAY,EACZ,SAAmB;IAEnB,IAAI,OAAO,GAA0B,IAAI,CAAC;IAE1C,OAAO,SAAS,gBAAgB,CAAC,GAAG,IAAO;QACzC,aAAa;QACb,4DAA4D;QAC5D,MAAM,OAAO,GAAG,IAAI,CAAC;QAErB,MAAM,KAAK,GAAG;YACZ,OAAO,GAAG,IAAI,CAAC;YACf,IAAI,CAAC,SAAS;gBAAE,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAC5C,CAAC,CAAC;QACF,MAAM,OAAO,GAAG,SAAS,IAAI,CAAC,OAAO,CAAC;QACtC,IAAI,OAAO;YAAE,YAAY,CAAC,OAAO,CAAC,CAAC;QACnC,OAAO,GAAG,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QAClC,IAAI,OAAO;YAAE,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IACzC,CAAC,CAAC;AACJ,CAAC;AArBD,4BAqBC","sourcesContent":["/**\n * Timer utility functions.\n * @module TimerUtils\n * @category Timer\n */\n\n/* eslint-disable func-names */\n/**\n * Runs a callback whenever the timer runs out. Resets the timer if is called again before the timer finishes.\n * @param callback\n * @param wait\n * @returns\n */\nexport function waitAndCallback<T extends Array<any>>(callback: (...args: T) => void, wait: number): (...args: T) => void {\n  let timeout: NodeJS.Timeout;\n  return (...args: T) => {\n    clearTimeout(timeout);\n    // @ts-ignore\n    timeout = setTimeout(function (): void { callback.apply(this, args); }, wait);\n  };\n}\n\n/**\n * Sleeps async for a given amount of time.\n * @param milisec\n * @returns\n */\nexport function asyncDelay(milisec: number): Promise<void> {\n  return new Promise<void>((resolve) => {\n    setTimeout(() => { resolve(); }, milisec);\n  });\n}\n\n/**\n * Creates an asynchronous delay.\n *\n *\n * IMPORTANT: This function is not meant to be used in production.\n * @param ms\n */\nexport function syncDelay(ms: number): void {\n  const end = Date.now() + ms;\n  while (Date.now() < end) continue;\n}\n\n/**\n * Function debouncer\n * @param func\n * @param wait\n * @param immediate runs immediatley when called\n * @returns\n */\nexport function debounce<T extends Array<any>>(\n  func: (...args: T) => void,\n  wait: number,\n  immediate?: boolean,\n) {\n  let timeout: NodeJS.Timeout | null = null;\n\n  return function executedFunction(...args: T) {\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const context = this;\n\n    const later = function () {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n    const callNow = immediate && !timeout;\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n}\n"]}